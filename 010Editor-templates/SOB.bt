//------------------------------------------------
//--- 010 Editor v7.0 Binary Template
//
//      File: SOB.bt
//   Authors: Alexandr Evdokimov
//   Version: 0.6
//   Purpose: Rainbow six .sob file format
// File Mask: .sob
// 
//   History: 
//
//   2018.04 v0.6 
//   2016    v0.5 initial release
//------------------------------------------------

struct {
  UINT Length; // 
  char Text[Length]; // 
} BEGINMODEL_STRING <name="BEGINMODEL">;

typedef struct { 
        UINT Length;  
        char Text[Length] <optimize=false>;
      } CString <optimize=false>; 

typedef struct {
  struct {
    UINT SectionSize;
    UINT ID; // 2

    UINT Length; // 
    char Text[Length]; //
    if (Text == "Version") {
      UINT value;
      struct {    
        UINT Length; // 
        char Text[Length]; //
      } MATERIALNAME_STRING <name="Material Name">;
    }; 
    struct {    
      UINT Length; // 
      char Text[Length]; //
   } TEXTURENAME_STRING <name="Texture FileName">; 
  } HEADER <name="Header">;



  struct { 
    FLOAT Opacity;
    FLOAT Emissive; // 0    
    UINT AlphaMethod; // 0 - Opaque, 1 - unknown, 3 - Lookup CXP or opaque
    struct {              
      UINT Red; //
      UINT Green; //
      UINT Blue; //
    } Ambient; 
    struct {           
      UINT Red; //
      UINT Green; //
      UINT Blue; //
    } Diffuse;   
    struct { 
      UINT Red; //
      UINT Green; //
      UINT Blue; //
    } Specular;
    FLOAT SpecularLevel; //o.o5
    BYTE twoSided;
  } Properties;
} MATERIAL <name=MaterialName>;

string MaterialName(MATERIAL &material) {
  return "Name: " + material.HEADER.TEXTURENAME_STRING.Text;
} 

struct {  
  struct { 
    UINT SectionSize;
    UINT ID; //8
    struct {
      UINT Length; // 
      char Text[Length]; // 
    } MATERIALLIST_STRING;
  } HEADER <name="1.0 MaterialList section header">;
    
  struct {
    UINT Count <name="Materials Count">;

    typedef struct (int arraySize) {
      MATERIAL array[arraySize] <optimize=false>;
    } MATERIAL_ARRAY; 

    MATERIAL_ARRAY MaterialArray(Count) <name="Material Array">; 
  } Materials <name="1.1 Materials section">;

} MATERIALLIST <name="MaterialList section">;


typedef struct  { 
   struct { 
     UINT Count; 
     CString Name; 
   } HEADER; 

   //Check(HEADER.Name.Length, 5, "AAAAA");

   struct {
     UINT VertexCount;
     UINT VertexIndices[VertexCount];

     UINT FaceCount; 
     UINT FaceIndices[FaceCount];
   } ARRAYS <name="Indexes">;  
   UINT GeometryFlags;  // Each bit corresponds to another flag on this mesh, such as Collision, Climbable, Invisible etc.
   CString String <name="String">;  
    
   UINT Unknown ;       
} OBJECT <name=objectName>;

string objectName(OBJECT &object) {
  return object.HEADER.Name.Text;
}

typedef struct {
     struct { 
       UINT SectionSize;
       UINT ID; // 7
   
       CString Text;
       if (Text.Text == "Version") { 
         UINT value;

         CString OBJECT_NAME;
         UINT A;
         UINT B;
       };
     } HEADER <name="Header">;  

    struct {
      UINT VertexCount;  
      typedef struct {     
        FLOAT X;
        FLOAT Y;
        FLOAT Z;
       } Vertex <name="Vertex">;
      typedef struct (int arraySize) {
        Vertex array[arraySize];
      } VERTEX_ARRAY;     
      VERTEX_ARRAY VertexArray(VertexCount) <name="Vertex array">; 
    } VERTICES <name="Vertices">;

    struct {
       UINT Count; 
       typedef struct {
         struct {
           FLOAT X;
           FLOAT Y;
           FLOAT Z;
         } NORMAL;
         struct {
           FLOAT U;
           FLOAT V;
         } UV;
         FLOAT Unknown;
         struct {
           UINT Red;
           UINT Green;
           UINT Blue;
         } Color;
        } VertexParameter <name="Vertex Parameter">;
       typedef struct (int arraySize) {
         VertexParameter array[arraySize] <optimize=false>;
       } VERTEX_PARAMETER_ARRAY;
       VERTEX_PARAMETER_ARRAY FArray(Count) <name="Vertex data array">; 
     } VERTEX_PARAMS_ARRAY <name="Vertex Parameters">;

     struct {
       UINT Count <name = "Face Count">; 
       typedef struct {     
         struct {
           UINT I1;
           UINT I2;
           UINT I3;
         } VERTEX_INDICES <name="Vertex indices">;  
         struct {
           UINT I1;
           UINT I2;
           UINT I3;
         } VERTEX_PARAM_INDICES <name="Vertex Param indices">;  
         struct {
           FLOAT MN;
           FLOAT MN;
           FLOAT MN;
           FLOAT MN;
         } FACE_NORMAL;
         UINT MaterialIndex;
       } FACE  <name="Face">;
       typedef struct (int arraySize) {
          FACE array[arraySize] <optimize=false>;
       } FACE_ARRAY;
       FACE_ARRAY FaceArray(Count)  <name="Faces">; 
     } FACE_DATA <name="Face Definitions">;

    struct {
      UINT Count; 
      typedef struct (int arraySize) {
        OBJECT array[arraySize] <optimize=false>;
      } OBJECTS;
      OBJECTS ObjArray(Count); 
    }  OBJECTSA <name="Meshes">; 
} DATA <name=ObjectName>;  

string ObjectName(DATA &data) {
  if (exists(data.HEADER.OBJECT_NAME))
    return "Name: " + data.HEADER.OBJECT_NAME.Text;
  else
    return "Name: " + data.Text;
}

struct {   
  struct { 
    UINT SectionSize;
    UINT ID; // 7
    struct {
      UINT Length;  
      char Text[Length];  
    } GEOMETRYLIST_STRING;
  } HEADER <name="GeometryList Header">;  

 UINT Count <name="Object Count">;
 struct {
  
    typedef struct (int arraySize) {
      DATA array[arraySize] <optimize=false>;
    } GEOMETRY_DATA_ARRAY; 

    GEOMETRY_DATA_ARRAY GeometryDataArray(Count) <name="Object geometry data array">; 
 } SOB_GEOMETRY_DATA <name="Geometry data">; 
}  GEOMETRYLIST  <name="GeometryList Section">;

struct {
  UINT Length; // 
  char Text[Length]; // 
} EndModelString <name="ENDMODEL">;
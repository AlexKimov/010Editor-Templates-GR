//------------------------------------------------
//--- 010 Editor v7.0 Binary Template
//
//      File: RSB.bt
//   Authors: Alexander Evdokimov
//   Version: 1.2
//   Purpose: Red storm bitmap (RSB) file
 
//   History: 
//   2017.12 v1.2 fix RSB version 0 structures
//   2017.05 v1.1 RSB with DXT1 compression and mipmaps added
//   2017.05 v0.9 RSB version 0 added
//   2017.01 v0.8 
//      New: 
//      - new structures, enums, vars, 
//      - speed optimization for pixel structure   
//   2016.10 v0.6 initial release
//
//------------------------------------------------

struct {
  local int height, width;
  local int DXT = 0;
} locals <hidden=true>;

typedef enum <ubyte> {
    no,
    yes
} BOOL; // bool data type

typedef enum <uint> {
  DXT1,
  DXT2, DXT3, DXT4,
  DXT5,
  none = 4294967295
} DXT_TYPE; 

typedef enum <uint> {
  sZero, 
  sOne, 
  sSource_Alpha, 
  sInverse_Source_Alpha, 
  sSource_Color, 
  sInverse_Source_Color, 
  sDestination_Color, 
  sInverse_Destination_Color, 
  sBoth_Source_Alpha, 
  sBoth_Inverse_Source_Alpha 
} SOURCE_FUNCTION_PARAMETER; 

typedef enum <uint> {
  dZero, 
  dOne, 
  dSource_Alpha, 
  dInverse_Source_Alpha_Source_Color, 
  dInverse_Source_Color, 
  dDestination_Color, 
  dInverse_Destination_Color, 
  dBoth_Source_Alpha, 
  dBoth_Inverse_Source_Alpha 
} DESTINATION_FUNCTION_PARAMETER; 

typedef enum <uint> {
  Never, 
  Less, 
  Equal, 
  Less_Equal, 
  Greater_Equal, 
  Always, 
} COMPARE_FUNCTION_PARAMETER;

typedef enum <uint>  {
  Cycle,
  Oscillate, 
  Constant
} ANIMATION_TYPE;

typedef enum <uint>  {
  Rotate,
  Degrees_Sec 
} SCROLLING_TYPE;

typedef enum <uint> {
  NONE, 
  Carpet, 
  Concrete, 
  Wood, 
  Metal, 
  Asphalt, 
  Sand, 
  Lowgrass, 
  Highgrass, 
  Puddle, 
  Water, 
  Drywall, 
  Thin_Metal, 
  Thick_Metal, 
  Metal_Gas_Tank, 
  Steam_Pipe, 
  Electrical_Panel, 
  Snow, 
  Safety_Glass, 
  Bullet_Resistant_Glass, 
  Ice, 
  Mud, 
  Glass, 
  Foliage, 
  Gravel, 
  Glass_Shards,
 unset = 4294967295
} SURFACE_TYPE ; 

typedef struct {
  UINT red_bits;
  UINT green_bits;
  UINT blue_bits;
  UINT alpha_bits;
} RSB_BIT_INFO <name="Bit Mask">;  

struct {
  UINT version; // *.rsb file version
  /* 
    0 - 1 games released before Ghost Recon: 
    Dominant Species, Bang Gunship Elite, Force 21, Rainbow six (1998) + addon, Rogue Spear(2000) + addons, Freedom First Resistance  
    0 - 9 Ghost Recon + addons (PC + consoles)), The Summ of All Fears
    9 - 11 Rainbow Six LockDown.
  */

  UINT width <name="Texture Width">; // texture width (128-2048)
  UINT height <name="Texture Height">; // texture height (128-2048) 
  if (version == 0)  {
    UINT Type;  // 8-bit image flag, 1 - it is 8-bit image in the file   
    if (Type == 0) {
      RSB_BIT_INFO BitInfo;  
    }  
  }
  else {
    if (version > 7) { 
      UINT mn;  
      BYTE mn1;
      BYTE mn2;
      BYTE mn3;
    }; 
    RSB_BIT_INFO BitInfo;  
    if (version >= 9) { 
      UINT mn; // 
      DXT_TYPE dxtType <name="DXT type">; // DXT compression type 0 - DXT1
      if ((dxtType >= 0) & (dxtType < 5)) {
        locals.DXT = 1;
      };
   };  
  }
} HEADER <name="File Header">;

typedef struct{
  ubyte Red    <name="Red">; 
  ubyte Green  <name="Green">;
  ubyte Blue   <name="Blue">;
  ubyte Alpha   <name="Alpha">; 
} PALLETE_COLOR <name="Pallete Color">;

if (HEADER.version == 0) {
  if (HEADER.Type == 1) {   
    PALLETE_COLOR Pallete[256] <name="8-bit Pallete">;
  };
};

BitfieldDisablePadding(); 

typedef struct {   
  if (HEADER.version == 0) {
    if (HEADER.Type == 1) { 
      ubyte PalleteColor <name="Pallete Color">;
    }
  } 
  else {
    if (locals.DXT == 1 ) {
        if (HEADER.dxtType != DXT1) {
          struct {
            if (HEADER.dxtType != DXT5) {
              for (i = 0; i < 16; ++i) {
                ubyte AlphaIndex : 4 <name="Alpha Index">; 
              }
            }
            else {
               ubyte Alpha1;
               ubyte Alpha2; 
               for (i = 0; i < 16; ++i) {
                ubyte AlphaIndex : 3 <name="Alpha Index">; 
              } 
            }            
          } AlphaChannel <name="Alpha Channel Data">;
        };
        struct {
          struct {
            ubyte Red : 5 <name="Red">; 
            ubyte Green   : 6 <name="Green">;
            ubyte Blue : 5 <name="Blue">; 
           } Color1;     
          struct {
            ubyte Red : 5 <name="Red">; 
            ubyte Green   : 6 <name="Green">;
            ubyte Blue : 5 <name="Blue">; 
          } Color2;  
          struct {
            for (i = 0; i < 16; ++i) {
              ubyte PixelIndex : 2 <name="Pixel Index">; 
            };
          } INDEX_TABLE;
        } COLOR_DATA <name="Color Data">;
    }
    else {
      if (HEADER.BitInfo.alpha_bits + HEADER.BitInfo.red_bits + HEADER.BitInfo.green_bits + HEADER.BitInfo.blue_bits == 32) {
       // ARGB order
        ubyte Alpha : HEADER.BitInfo.alpha_bits <name="Alpha">; 
        ubyte Red   : HEADER.BitInfo.red_bits <name="Red">;
        ubyte Green : HEADER.BitInfo.green_bits <name="Green">;
        ubyte Blue  : HEADER.BitInfo.blue_bits <name="Blue">;
      } 
      else {
        // BGR order
        ubyte Blue  : HEADER.BitInfo.blue_bits <name="Blue">;
        ubyte Green : HEADER.BitInfo.green_bits <name="Green">;
        ubyte Red   : HEADER.BitInfo.red_bits <name="Red">;
        ubyte Alpha : HEADER.BitInfo.alpha_bits <name="Alpha">; 
      };
    };
  };
} PIXEL <name="Pixel", size=sizePIXEL>;

int sizePIXEL( PIXEL &pixel )
{
  if ((HEADER.version == 0)) {
    if (HEADER.Type == 1) {
      return 1;
    }
  } 
  else {
    if (locals.DXT == 1) { 
      if (HEADER.dxtType == 0) { 
        return 8; 
      }
      else
     if (HEADER.dxtType > 0 && HEADER.dxtType < 5 ) { 
        return 16; 
      }
    }
    else {
    return (HEADER.BitInfo.red_bits + 
            HEADER.BitInfo.green_bits + 
            HEADER.BitInfo.blue_bits + 
            HEADER.BitInfo.alpha_bits)/8;
    }
  }
} 

typedef struct (int arraySize) {
  PIXEL array[arraySize] <optimize=false>;
} PIXEL_ARRAY;

if (locals.DXT == 1) {
    PIXEL_ARRAY PixelArray(HEADER.width*HEADER.height/16) <name="Pixel Array (DXT compression)", optimize=false>;
} else {
  PIXEL_ARRAY PixelArray(HEADER.width*HEADER.height) <name="Pixel Array", optimize=false>;
};

if (HEADER.version == 0) { 
if (HEADER.Type == 1) { 
    struct {
       UINT red_bits;
       UINT green_bits;
       UINT blue_bits;
       UINT alpha_bits;
    } RSB_BIT_INFO2 <name="Bit mask">;
    typedef struct {   
      ubyte Alpha : RSB_BIT_INFO2.red_bits <name="Alpha">; 
      ubyte Red   : RSB_BIT_INFO2.green_bits <name="Red">;
      ubyte Green : RSB_BIT_INFO2.blue_bits <name="Green">;
      ubyte Blue  : RSB_BIT_INFO2. alpha_bits <name="Blue">; 
    } PIXEL2 <name="Pixel", optimize=false>;
    typedef struct (int arraySize) {
      PIXEL2 array[arraySize] <optimize=false>;
    } PIXEL_ARRAY2;

  PIXEL_ARRAY2 PixelArray(HEADER.width*HEADER.height) <name="Pixel Array">;
} 
}

typedef struct {
    locals.height = HEADER.height, locals.width = HEADER.width;
  for (i = 0; i < RSB_PROPERTIES.MapsCount; ++i)
    {
       locals.height = locals.height/2; 
       locals.width = locals.width/2;
       PIXEL_ARRAY MipMapArray(locals.height*locals.width) <name="Mip Map">;      
    };
} MIP_MAPS <name="MipMaps">;

typedef struct {
  UINT Length;
  char Name[Length];
  UINT Count;
  typedef struct {
    UINT P1;
    UINT P2;    
    SHORT X1;
    SHORT Y1;
    SHORT X2;
    SHORT Y2;
  } Coordinates; 
  Coordinates DATA[Count];
} Channel <name=channelName>; 

string channelName(Channel &channel){
  return channel.Name;
}

if (HEADER.version > 2) {    
    struct{
       if ((HEADER.version > 5) && (HEADER.version < 10)) {
        struct {  
         UINT SurfaceChannelsCount; // 

         // surface channel section
         if (SurfaceChannelsCount > 0) {            
             UINT size;
             BYTE SurfaceChannelsData[size];
             Channel Array[SurfaceChannelsCount] <optimize=false>;  
           };
         }SurfaceData <name="Surface Channels">; 
       } ; 
      
      if (HEADER.version > 9) {
         UINT Count;
         UINT MN[Count];
         UINT MN;
       };

       BOOL AlphaBlending <name="AlphaBlending", comment="">;
       BOOL AlphaTesting <name="AlphaTesting">;
       BOOL Sampling <name="Sampling">;
       BOOL Animation <name="Animation">;
       BOOL Scrolling <name="Scrolling">;
       BOOL Tiled <name="Tiled">;   // unused
       BOOL Compression <name="Compression">;   // unused       
       //
       if (HEADER.version > 7) {
         BOOL Distortion <name="Distortion">;
       };
       UINT GameProperties;
    
       SOURCE_FUNCTION_PARAMETER SourceFunction <name="Source Function">;
       DESTINATION_FUNCTION_PARAMETER DestinationFunction <name="Destination Function">;
       COMPARE_FUNCTION_PARAMETER CompareFunction <name="Compare Function">;
       BYTE ReferenceValue;
    
       struct { 
         SCROLLING_TYPE ScrollingType;    
         FLOAT HorizontalRate;
         FLOAT VerticalRate;
       } TEXTURE_SCROLLING <name="Scrolling">;
      
       struct {
         ANIMATION_TYPE AnimationType <name="Animation Type">; 
         FLOAT AnimationInterval;
         UINT TextureCount;
         if ((TextureCount)) {
              typedef struct {
                UINT TextureNameLength;
                char TextureName[TextureNameLength]; 
              } TEXTURE_NAME <optimize=false>;
        
              typedef struct (int arraySize) {
                TEXTURE_NAME array[arraySize];
              } TEXTURE_ARRAY <optimize=false>;
   
             TEXTURE_ARRAY RSBTextureArray(TextureCount) <optimize=false>; 
          };
       } ANIMATION <name="Animation">; 

       if (HEADER.version > 4) {        
         UINT MapsCount;   
         UINT SubsamplingPriority;  
       };

       BOOL Damaged <name="Damaged">;    
       if (Damaged == yes) {
         UINT TextureNameLength; // 
         if (TextureNameLength > 0) {
             char DamagedTextureName[TextureNameLength];
         };
       }; 
    

       SURFACE_TYPE SurfaceType <name="Surface Type">;   
    } RSB_PROPERTIES <name="Texture Properties">;

  if (HEADER.version > 4) {
    if (RSB_PROPERTIES.MapsCount > 0) {     
      MIP_MAPS MipMaps;
    }
  }
}; 

 

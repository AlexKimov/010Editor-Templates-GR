//------------------------------------------------
//--- 010 Editor v7.0 Binary Template
//
//      File: MAP(rs).bt
//   Authors: Alexander Evdokimov
//   Version: 0.5
//   Purpose: Rainbow Six MAP file 
// File Mask: *.map
// 
//   History: 
//
//   2017 v0.5 initial release
//
//------------------------------------------------

typedef enum <byte> {
  yes = 1,
  no = 0
} BOOL;

typedef struct { 
  UINT Length;  
  char Text[Length];
} CSTRING; 

typedef struct {
  struct { 
    FLOAT x;        
    FLOAT y;
    FLOAT z;
  } X;
  struct { 
    FLOAT x;
    FLOAT y;
    FLOAT z;
  } Y;
  struct {
    FLOAT x;
    FLOAT y;
    FLOAT z;
  } Z;
  struct {
    FLOAT x;
    FLOAT y;
    FLOAT z;
  } POSITION;
} TRANSFORMATION_MATRIX;   

typedef struct {
  UINT SectionSize;
  UINT ID;
  CSTRING Name; 
  if (Name.Text == "Version") 
  {
    UINT value;
    CSTRING Name;
  }; 
} SECTION_HEADER <name="Header">;

typedef enum <uint> {
  Opaque = 0, 
  unknown = 1,
  LookupCXP = 3
} ALPHA_METHOD <name="File Header">;

typedef struct {
  UINT Red;
  UINT Green;
  UINT Blue;  
} COLOR;

//-------------------------------------------------------
// Header
//-------------------------------------------------------

struct {
  CSTRING Name <name="BeginMapv2.1">;
  time_t DateTime;
} HEADER <name="File header">;

//-------------------------------------------------------
// MaterialList
//-------------------------------------------------------

typedef struct {
  SECTION_HEADER Header;
  CSTRING Name <name="Texture filename">; 
  struct { 
    FLOAT Opacity;
    FLOAT Emissive; // 0    
    ALPHA_METHOD alpha; // 0 - Opaque, 1 - unknown, 3 - Lookup CXP or opaque
    COLOR Ambient; 
    COLOR Diffuse;   
    COLOR Specular;
    FLOAT SpecularLevel; //o.o5
    BOOL twoSided;
  } MATERIAL_PROPERTIES;
} MATERIAL <name=MaterialName>;

string MaterialName(MATERIAL &material) {
  return "Name: " + material.Header.Name.Text;
} 

struct {  
  SECTION_HEADER Header;    
  UINT Count <name="Number of materials">;
  typedef struct (int arraySize) {
    MATERIAL array[arraySize] <optimize=false>;
  } MATERIALS; 
  MATERIALS Materials(Count) <name="Materials">; 
} MATERIAL_LIST <name="Material list">;

//-------------------------------------------------------
// GeometryList
//-------------------------------------------------------

typedef struct  { 
   struct { 
     UINT Count; 
     CSTRING Name; 
   } HEADER; 

   struct {
     UINT VertexCount;
     UINT VertexIndices[VertexCount];

     UINT FaceCount; 
     UINT FaceIndices[FaceCount];
   } ARRAYS <name="Indexes">;  
   UINT GeometryFlags;  // Each bit corresponds to another flag on this mesh, such as Collision, Climbable, Invisible etc.
   CSTRING String <name="String">;  
    
   UINT Unknown ;       
} OBJECT <name=objectName>;

string objectName(OBJECT &object) {
  return object.HEADER.Name.Text;
}

typedef struct {
    SECTION_HEADER Header;  
    UINT Unknown;
    UINT Unknown;
    struct {
      UINT VertexCount;  
      typedef struct {     
        FLOAT X;
        FLOAT Y;
        FLOAT Z;
       } Vertex <name="Vertex">;
      typedef struct (int arraySize) {
        Vertex array[arraySize];
      } VERTEX_ARRAY;     
      VERTEX_ARRAY VertexArray(VertexCount) <name="Vertex array">; 
    } VERTICES <name="Vertices">;

    struct {
       UINT Count; 
       typedef struct {
         struct {
           FLOAT X;
           FLOAT Y;
           FLOAT Z;
         } NORMAL;
         struct {
           FLOAT U;
           FLOAT V;
         } UV;
         FLOAT Unknown;
         struct {
           UINT Red;
           UINT Green;
           UINT Blue;
         } Color;
        } VertexParameter <name="Vertex Parameter">;
       typedef struct (int arraySize) {
         VertexParameter array[arraySize] <optimize=false>;
       } VERTEX_PARAMETER_ARRAY;
       VERTEX_PARAMETER_ARRAY FArray(Count) <name="Vertex data array">; 
     } VERTEX_PARAMS_ARRAY <name="Vertex Parameters">;

     struct {
       UINT Count <name = "Face Count">; 
       typedef struct {     
         struct {
           UINT I1;
           UINT I2;
           UINT I3;
         } VERTEX_INDICES <name="Vertex indices">;  
         struct {
           UINT I1;
           UINT I2;
           UINT I3;
         } VERTEX_PARAM_INDICES <name="Vertex Param indices">;  
         struct {
           FLOAT MN;
           FLOAT MN;
           FLOAT MN;
           FLOAT MN;
         } FACE_NORMAL;
         UINT MaterialIndex;
       } FACE  <name="Face">;
       typedef struct (int arraySize) {
          FACE array[arraySize] <optimize=false>;
       } FACE_ARRAY;
       FACE_ARRAY FaceArray(Count)  <name="Faces">; 
     } FACE_DATA <name="Face Definitions">;

    struct {
      UINT Count; 
      typedef struct (int arraySize) {
        OBJECT array[arraySize] <optimize=false>;
      } OBJECTS;
      OBJECTS ObjArray(Count); 
    }  OBJECTSA <name="Meshes">; 
} OBJECT <name=ObjectName>;  

string ObjectName(DATA &data) {
  if (exists(data.HEADER.OBJECT_NAME))
    return "Name: " + OBJECT.Header.Name.Text;
  else
    return "Name: " + OBJECT.Text;
}

struct {   
  SECTION_HEADER Header;  
  UINT Count <name="Number of objects">;
  typedef struct (int arraySize) {
    OBJECT array[arraySize] <optimize=false>;
  } OBJECTS; 
  OBJECTS Objects(Count) <name="Objects">; 
}  GEOMETRY_LIST  <name="Geometry List">;

//-------------------------------------------------------
// Portal List Section
//-------------------------------------------------

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 9
    struct {
      UINT Length;  
      char Text[Length];  
    } PORTALLIST_STRING;
  } HEADER <name="PORTALList Header">;   

  UINT Count;

  typedef struct {
    struct { 
      UINT SectionSize;
      UINT ID; // 0
      struct {
        UINT Length;  
        char Text[Length]; 
        UINT value; 
      } Version;
      struct {
        UINT Length;  
        char Text[Length];
      } Name;
    } HEADER <name="Header">; 
    
    UINT VertexCount;
    typedef struct {
        FLOAT x;
        FLOAT y;
        FLOAT z;  
    } COORDINATES <name="Vertex Coordinates">;
    COORDINATES CoordinatesArray[VertexCount];      
    UINT RoomNumber;
    UINT OpositeRoomNumber; 

  } PORTAL <name=PortalName>;

  typedef struct (int arraySize) {
      PORTAL array[arraySize] <optimize=false>;
  } PORTAL_ARRAY;
  PORTAL_ARRAY ObjectNameArray(Count) <name="Portals">;
  
} PORTALLIST <name="Portal List">;

string PortalName(PORTAL &portal) {
  return "Name: " + portal.HEADER.Name.Text;
};


//-------------------------------------------------------
// LIGHTLIST Section
//-------------------------------------------------------

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 1
    struct {
      UINT Length;  
      char Text[Length];  
    } LIGHTLIST_STRING;
  } HEADER <name="LIGHTList Header">;  

  UINT Count; 
  typedef struct {
     struct { 
       UINT SectionSize;
       UINT ID; // 13
       UINT Length; // 
       char Text[Length]; 
       if (Text == "Version")
       struct {    
        //
         UINT value;
         UINT Length;  
         char Text[Length]; 
         BYTE Y;  
       } NAME_STRING;
     } HEADER <name="Header">;   
     BYTE A;
     BYTE B;
     BYTE C;
     TRANSFORMATION_MATRIX TM; 
     struct {
       struct {
         UINT R; // 0..255
         UINT G; //
         UINT B;
       } Color;
       FLOAT ConstantAttenuation; // 1
       FLOAT LinearAttenuation; // 0
       FLOAT QuadraticAttenuation; //  0
       FLOAT Falloff; // 
       FLOAT Energy;
       BYTE Type;
     } Params;
  } LIGHT <name=LightName>;
  typedef struct (int arraySize) {
      LIGHT array[arraySize] <optimize=false>;
  } LIGHT_ARRAY;
  LIGHT_ARRAY LIGHTArray(Count) <name="Lights">;
} LIGHTLIST <name="Light List">;

string LightName(LIGHT &light) {
  if (exists(light.HEADER.NAME_STRING))
    return "Name: " + light.HEADER.NAME_STRING.Text;
  else
    return "Name: " + light.HEADER.Text;
};


//-------------------------------------------------------
// ObjectLIST Section
//-------------------------------------------------------

typedef struct {
  struct { 
       UINT SectionSize;
       UINT ID; // 16
      struct {    
        UINT Length; // 
        char Text[Length]; //
        UINT value;
      } VERSION; 
       struct {
         UINT Length;  
         char Text[Length];  
       } NAME;
       struct {
         UINT Length;  
         char Text[Length];  
       } FileName;
  } HEADER <name="Header">;
     
  struct { 
     switch (HEADER.ID) {
       case 14: {
         TRANSFORMATION_MATRIX TM <name="Position">;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[3] <optimize=false>; 
         BYTE A;
         BYTE B;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[2] <optimize=false>; 
         UINT AE[3];      
       };break;

       // door
       case 16: {
        TRANSFORMATION_MATRIX TM <name="Position">;
     
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } HIT_Sound <name="Hit Sound">;  
         struct {
           UINT Length;  
           char Text[Length];  
         } DEBRIS <name="Debris">;  

         BYTE A;
         BYTE B;   
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } polygon <name="polygon">; 

         UINT H[3];    
         struct {
           UINT Length;  
           char Text[Length];  
         } OPEN_Sound <name="Start sound">;  
         struct {
           UINT Length;  
           char Text[Length];  
         } CLOSE_Sound <name="Stop Sound">;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  

         BYTE A;
         struct {
           struct {
             UINT Length;  
             char Text[Length];  
           } Animation_Type <name="Animation Type">; 
           struct {
             FLOAT X;
             FLOAT Y;
             FLOAT Z;
           } Direction <name="Direction">;
           FLOAT Distance;
           FLOAT Velocity;
         } ANIMATION <name= "Animation">;
         BYTE A;
         BYTE B;  
       }; break;


       case 17: {
        TRANSFORMATION_MATRIX TM <name="Position">;
        struct {
           UINT Length;  
           char Text[Length];  
         } NAME[3] <optimize=false>;  
         BYTE A;
         BYTE B;   
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME2[2] <optimize=false>; 
         UINT H[3];    
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME3[3] <optimize=false>; 
         BYTE A;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME <optimize=false>; 
         FLOAT C[5]; 
       }; break;

       case 19: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;

         BYTE A;
         BYTE B; 
 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME; 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;

         UINT A;
         UINT B; 


         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME; 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;

         BYTE B;  
 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;   

         BYTE I[25];     
       }; break;

       // Glass
       case 20: {
         TRANSFORMATION_MATRIX TM;
         BYTE C;
         FLOAT GG[6];
         UINT VertexCount; // 4
         typedef struct { 
            FLOAT x;        
            FLOAT y;
            FLOAT z;
         } Coordinates;  
         typedef struct (int arraySize) {
           Coordinates array[arraySize] <optimize=false>;
         } Coordinates_ARRAY;  
         Coordinates_ARRAY  CA(VertexCount) <optimize=false>;
       }; break;

       case 21: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         FLOAT YY[6]; 
         UINT Count;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[Count] <optimize=false>;  
       }; break;

       case 25: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME; 
         FLOAT J[6];
         UINT Count;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[Count] <optimize=false>; 
       }; break;   

       case 29: {
         TRANSFORMATION_MATRIX TM;
         UINT Count;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[Count] <optimize=false>;  
       }; break;

       case 31: {
         TRANSFORMATION_MATRIX TM;
         UINT Count;
         typedef struct {
           FLOAT X; 
           FLOAT Y;        
           FLOAT Z;
           struct {
             UINT Length;  
             char Text[Length];  
           } NAME;             
         } Q;
         typedef struct (int arraySize) {
           Q array[arraySize] <optimize=false>;
         } Q_ARRAY;
         Q_ARRAY QArray(Count);
 
       }; break;

       case 33: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         FLOAT YY[7];       
       }; break;

    }; 
  } PROPERTIES;      
} OBJECT_NAME <name=ObjName>;

string ObjName(OBJECT_NAME &objectname) {
  return "Name: " + objectname.HEADER.NAME.Text + " ";
}

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 10
    struct {
      UINT Length;  
      char Text[Length];  
    } LIGHTLIST_STRING;
  } HEADER <name="ObjectList Header">; 

  UINT Count; 

  typedef struct (int arraySize) {
      OBJECT_NAME array[arraySize] <optimize=false>;
  } OBJECT_NAME_ARRAY;
  OBJECT_NAME_ARRAY ObjectNameArray(Count) <name="Object Array">;
  
} ObjectLIST <name="Object List">;

//-------------------------------------------------------
// RoomList Section
//-------------------------------------------------------

void Nodes() {
  struct { 
    UINT ID; //

    UINT Length;  
    char Text[Length]; 
    if (Text == "Version") {
      UINT value; 
      struct {
        UINT Length;  
        char Text[Length];
      } NAME;
    };
  } HEADER <name="Header">;   
 

    BYTE A;
    BYTE B;        
    if (A == 0) BYTE C;
    UINT ShermanCount;
    local uint scount = ShermanCount;
    //local uint i = 0;
    //if (B != 1) scount = 1;
    if (ShermanCount == 0) BYTE A; 
    struct { 
     
      struct { 
        UINT Length;  
        char ShermanLevel[Length];
      } Name <optimize=false>;
      FLOAT T[6];
      UINT Count; 
      FLOAT Z[Count];
      BYTE Y;
      if (Y == 1) {
          UINT AA;
          struct { 
            UINT ID; //
        
            UINT Length;  
            char Text[Length]; 
            if (Text == "Version") {
              UINT value; 
              struct {
                UINT Length;  
                char Text[Length];
              } NAME;
            };
          } HEADER <name="Header">;   

        BYTE A;
        BYTE B;
        BYTE C;
        BYTE D;
        UINT U;
        UINT Count;
        struct {
           FLOAT P1;
           FLOAT P2;
           FLOAT P3;
        } Coordinate[Count];
        UINT Count;
        struct {
           FLOAT P1;
           FLOAT P2;
           FLOAT P3;
           FLOAT P1;
           FLOAT P2;
           FLOAT P3;
           UINT P1;
           UINT  P2;
           UINT  P3;
        } Coordinate2[Count];
        UINT Count; 
        struct {
           UINT P1[11];
        } Coordinate3[Count];    
        UINT Count; 
        UINT Count;
        struct {
          UINT Length;  
          char Text[Length];
        } Name <optimize=false>;   
        UINT Count; 
        UINT CountA;
        struct {
          UINT CountA;
        } Arr[CountA];

        UINT Count; 
        struct {
          UINT Length;  
          char Text[Length];
        } Name <optimize=false>;   
        UINT Count;
     };
    } ShermanLevelPlanArea[scount] <optimize=false>;

    UINT Count;
    struct {
      CSTRING TransitionName;
      CSTRING LevelA;
      CSTRING LevelB;
      FLOAT T[4];
    } ShermanLevelTransition[Count] <optimize=false>;
  
    UINT Count;
    FLOAT arr[Count]; // 1
    FLOAT T[Count];
    UINT Count;
    FLOAT O[Count];

};


typedef struct {
  Nodes();   
} ROOM <name=RoomName>;

string RoomName(ROOM &room) {
  if (exists(room.HEADER.NAME))
    return "Room Name: " + room.HEADER.NAME.Text + " ";
  else
    return "Room Name: " + room.Text + " ";
}

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 7
    struct {
      UINT Length;  
      char Text[Length];  
    } ROOMLIST_STRING;
  } HEADER <name="ROOMList Header">;

  UINT Count; 

  typedef struct (int arraySize) {
      ROOM array[arraySize] <optimize=false>;
  } ROOM_ARRAY;
  ROOM_ARRAY ROoomArray(Count) <name="data array">;

   
} ROOMLIST <name="Room List">;

UINT L;

//----------------------------------------------
// PlanningLevelLIST
//----------------------------------------------

struct {
  struct { 
    UINT ID; // 24
    struct {
      UINT Length;  
      char Text[Length];  
    } PlanningLevelLIST_STRING;
  } HEADER <name="ROOMList Header">;
  
  UINT Count; 

  typedef struct {
    FLOAT A;
    FLOAT B;
    UINT Count;
    typedef struct {
    struct {
      UINT Length;  
      char Text[Length];
    } NAME;
    } A;
    A MN[Count] <optimize=false>;
  } II;
  typedef struct (int arraySize) {
      II array[arraySize] <optimize=false>;
  } II_ARRAY;
  II_ARRAY IIArray(Count) <name="data array">;
 
  BYTE Y;
} PlanningLevelLIST <name="PlanningLevel List">;

struct {
      UINT Length;  
      char Text[Length];  
} EndMap <name="EndMap">;
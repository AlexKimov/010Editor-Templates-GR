//------------------------------------------------
//--- 010 Editor v7.0 Binary Template
//
//      File: MAP(rs).bt
//   Authors: Alexander Evdokimov
//   Version: 0.5
//   Purpose: Rainbow Six MAP file 
// File Mask: *.map
// 
//   History: 
//
//   2017 v0.5 initial release
//
//------------------------------------------------

typedef struct {
  struct { 
    FLOAT x;        
    FLOAT y;
    FLOAT z;
  } XAXIS;
  struct { 
    FLOAT x;
    FLOAT y;
    FLOAT z;
  } YAXIS;
  struct {
    FLOAT x;
    FLOAT y;
    FLOAT z;
  } ZAXIS;
  struct {
    FLOAT Y;
    FLOAT X;
    FLOAT Z;
  } POSITION;
} TRANSFORMATION_MATRIX;   

struct {
  struct {
    UINT Length; // 
    char Text[Length]; // 
  } BeginMap_STRING <name="BeginMapv2.1">;
  time_t DateTime;
} HEADER <name="Header">;

typedef struct {
  struct {
    UINT SectionSize;
    UINT ID;

    UINT Length; // 
    char Text[Length]; //
    if (Text == "Version") {
      UINT value;
      struct {    
        UINT Length; // 
        char Text[Length]; //
      } MATERIALNAME_STRING <name="Material Name">;
    }; 
  } HEADER <name="Header">;

  struct {    
    UINT Length; // 
    char Text[Length]; //
 } MATERIALNAME_STRING <name="Texture FileName">; 

  struct { 
    FLOAT Opacity;
    FLOAT SelfIllumination;
    UINT AdvTransparencyType;
    struct {              
      UINT Red; //
      UINT Green; //
      UINT Blue; //
    } Ambient; 
    struct {           
      UINT Red; //
      UINT Green; //
      UINT Blue; //
    } Diffuse;   
    struct { 
      UINT Red; //
      UINT Green; //
      UINT Blue; //
    } Specular;
    FLOAT SpecularLevel; //o.o5
    BYTE twoSided;
  } Properties;
} MATERIAL <name=MaterialName>;

string MaterialName(MATERIAL &material) {
  if (exists(HEADER.MATERIALNAME_STRING))
    return "Name: " + material.HEADER.MATERIALNAME_STRING.Text;
  else
    return "Name: " + material.HEADER.Text;
} 

struct {  
  struct { 
    UINT SectionSize;
    UINT ID; // 8
    struct {
      UINT Length; // 
      char Text[Length]; // 
    } MATERIALLIST_STRING;
  } HEADER <name="1.0 MaterialList section header">;
    
  struct {
    UINT Count <name="Materials Count">;

    typedef struct (int arraySize) {
      MATERIAL array[arraySize] <optimize=false>;
    } MATERIAL_ARRAY; 

    MATERIAL_ARRAY MaterialArray(Count) <name="Material Array">; 
  } Materials <name="1.1 Materials section">;

} MATERIALLIST <name="MaterialList section">;

//-------------------------------------------------------

typedef struct  { 
   struct { 
     UINT Count; 
     struct {
       UINT Length; 
       char Text[Length]; 
     } Name; 
   } HEADER; 

   struct {
     UINT Count; 
     typedef struct {  
       UINT Index; 
     } CC;
     typedef struct (int arraySize) {
       CC array[arraySize] <optimize=false>;
     } CC_ARRAY;
     CC_ARRAY CCArray(Count) <name="Face indexes">; 

     UINT Count; 
     typedef struct {  
       UBYTE Index; 
       UBYTE MN; 
       UINT16 MN;
     } DD;
     typedef struct (int arraySize) {
       DD array[arraySize] <optimize=false>;
     } DD_ARRAY;
     DD_ARRAY DDArray(Count) <name="Collision">; 
   } ARRAYS;       

   UINT Count; 
   struct {
     UINT Length; // 
     char Text[Length]; // 
   } String <name="String">;      
   UINT Count;       
} OBJECT <name=objectName>;

string objectName(OBJECT &object) {
  return object.HEADER.Name.Text;
}

typedef struct {
     struct { 
       UINT SectionSize;
       UINT ID; // 7
   
       UINT Length; // 
       char Text[Length]; //
       if (Text == "Version") { 
         UINT value;

         struct {
           UINT Length;  
           char Text[Length];  
         } OBJECT_NAME;
         UINT A;
         UINT B;
       };
     } HEADER <name="Header">;  

    struct {
      UINT VertexCount;  
      typedef struct {     
        FLOAT P1;
        FLOAT P2;
        FLOAT P3;
       } Vertex <name="Vertex">;    
      typedef struct (int arraySize) {
        Vertex array[arraySize];
      } VERTEX_ARRAY;     
      VERTEX_ARRAY VertexArray(VertexCount) <name="Vertex array">; 
    } VERTICES <name="Vertices">;

    struct {
       UINT Count; 
       typedef struct {
         struct {
           FLOAT X;
           FLOAT Y;
           FLOAT Z;
           FLOAT W;
         } NORMAL;
         struct {
           FLOAT U;
           FLOAT V;
         } UV;
         struct {
           UINT Red;
           UINT Green;
           UINT Blue;
         } Color;
        } F <name="Vertex">;
       typedef struct (int arraySize) {
         F array[arraySize] <optimize=false>;
       } F_ARRAY;
       F_ARRAY FArray(Count) <name="Vertex data array">; 
     } FACE_ARRAY <name="Texture coordinates">;

     struct {
       UINT Count <name = "Face Count">; 
       typedef struct {     
         struct {
           UINT I1;
           UINT I2;
           UINT I3;
         } INDEXIES1 <name="Face index">;  
         struct {
           UINT I1;
           UINT I2;
           UINT I3;
         } INDEXIES2 <name="Texture coordinates index">;  
         struct {
           FLOAT MN;
           FLOAT MN;
           FLOAT MN;
         } FACE_NORMAL;
         UINT MN;
         UINT TextureIndex;
       } FACE  <name="Face">;
       typedef struct (int arraySize) {
          FACE array[arraySize] <optimize=false>;
       } FACE_ARRAY;
       FACE_ARRAY FaceArray(Count)  <name="Faces">; 
     } TEXTURE_DATA <name="Indexes">;

    struct {
      UINT Count; 
      typedef struct (int arraySize) {
        OBJECT array[arraySize] <optimize=false>;
      } OBJECTS;
      OBJECTS ObjArray(Count); 
    }  OBJECTSA <name="Meshes">; 
} DATA <name=ObjectName>;  

string ObjectName(DATA &data) {
  if (exists(data.HEADER.OBJECT_NAME))
    return "Name: " + data.HEADER.OBJECT_NAME.Text;
  else
    return "Name: " + data.Text;
}

struct {   
  struct { 
    UINT SectionSize;
    UINT ID; // 7
    struct {
      UINT Length;  
      char Text[Length];  
    } GEOMETRYLIST_STRING;
  } HEADER <name="GeometryList Header">;  

 UINT Count <name="Object Count">;
 struct {
  
    typedef struct (int arraySize) {
      DATA array[arraySize] <optimize=false>;
    } GEOMETRY_DATA_ARRAY; 

    GEOMETRY_DATA_ARRAY GeometryDataArray(Count) <name="Object geometry data array">; 
 } SOB_GEOMETRY_DATA <name="Geometry data">; 
}  GEOMETRYLIST  <name="GeometryList Section">;

//-------------------------------------------------------
// Portal List Section
//-------------------------------------------------

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 9
    struct {
      UINT Length;  
      char Text[Length];  
    } PORTALLIST_STRING;
  } HEADER <name="PORTALList Header">;   

  UINT Count;

  typedef struct {
    struct { 
      UINT SectionSize;
      UINT ID; // 0
      struct {
        UINT Length;  
        char Text[Length]; 
        UINT value; 
      } Version;
      struct {
        UINT Length;  
        char Text[Length];
      } Name;
    } HEADER <name="Header">; 
    
    UINT VertexCount;
    typedef struct {
        FLOAT x;
        FLOAT y;
        FLOAT z;  
    } COORDINATES <name="Vertex Coordinates">;
    COORDINATES CoordinatesArray[VertexCount];      
    UINT RoomNumber;
    UINT OpositeRoomNumber; 

  } PORTAL <name=PortalName>;

  typedef struct (int arraySize) {
      PORTAL array[arraySize] <optimize=false>;
  } PORTAL_ARRAY;
  PORTAL_ARRAY ObjectNameArray(Count) <name="Portals">;
  
} PORTALLIST <name="Portal List">;

string PortalName(PORTAL &portal) {
  return "Name: " + portal.HEADER.Name.Text;
};


//-------------------------------------------------------
// LIGHTLIST Section
//-------------------------------------------------------

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 1
    struct {
      UINT Length;  
      char Text[Length];  
    } LIGHTLIST_STRING;
  } HEADER <name="LIGHTList Header">;  

  UINT Count; 
  typedef struct {
     struct { 
       UINT SectionSize;
       UINT ID; // 13
       UINT Length; // 
       char Text[Length]; 
       if (Text == "Version")
       struct {    
        //
         UINT value;
         UINT Length;  
         char Text[Length]; 
         BYTE Y;  
       } NAME_STRING;
     } HEADER <name="Header">;   
     BYTE A[3];
     TRANSFORMATION_MATRIX TM; 
     struct {
       UINT MN; // 0
       UINT MN; //
       UINT MN;
       FLOAT MN; //
       FLOAT MN; // 
       FLOAT MN; // 
       FLOAT MN; // 
       FLOAT Atennuation;
       BYTE A;
     } Params;
  } LIGHT <name=LightName>;
  typedef struct (int arraySize) {
      LIGHT array[arraySize] <optimize=false>;
  } LIGHT_ARRAY;
  LIGHT_ARRAY LIGHTArray(Count) <name="Lights">;
} LIGHTLIST <name="Light List">;

string LightName(LIGHT &light) {
  if (exists(light.HEADER.NAME_STRING))
    return "Name: " + light.HEADER.NAME_STRING.Text;
  else
    return "Name: " + light.HEADER.Text;
};


//-------------------------------------------------------
// ObjectLIST Section
//-------------------------------------------------------

typedef struct {
  struct { 
       UINT SectionSize;
       UINT ID; // 16
      struct {    
        UINT Length; // 
        char Text[Length]; //
        UINT value;
      } VERSION; 
       struct {
         UINT Length;  
         char Text[Length];  
       } NAME;
       struct {
         UINT Length;  
         char Text[Length];  
       } FileName;
  } HEADER <name="Header">;
     
  struct { 
     switch (HEADER.ID) {
       case 16: {
        TRANSFORMATION_MATRIX TM <name="Position">;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[3] <optimize=false>;  
         BYTE A;
         BYTE B;   
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME2[2] <optimize=false>; 
         UINT H[3];    
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME3[3] <optimize=false>; 
         BYTE A;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME <optimize=false>; 
         FLOAT C[5];
         BYTE A;
         BYTE B;  
       }; break;


       case 17: {
        TRANSFORMATION_MATRIX TM <name="Position">;
        struct {
           UINT Length;  
           char Text[Length];  
         } NAME[3] <optimize=false>;  
         BYTE A;
         BYTE B;   
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME2[2] <optimize=false>; 
         UINT H[3];    
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME3[3] <optimize=false>; 
         BYTE A;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME <optimize=false>; 
         FLOAT C[5]; 
       }; break;

       case 19: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;

         BYTE A;
         BYTE B; 
 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME; 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;

         UINT A;
         UINT B; 


         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME; 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;

         BYTE B;  
 
         struct {
           UINT Length;  
           char Text[Length] ;  
         } NAME;   

         BYTE I[25];     
       }; break;


       case 20: {
         TRANSFORMATION_MATRIX TM;
         BYTE C;
         FLOAT GH[19];
       }; break;

       case 21: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         FLOAT YY[6]; 
         UINT Count;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME[Count] <optimize=false>;  
       }; break;

       case 33: {
         TRANSFORMATION_MATRIX TM;
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         struct {
           UINT Length;  
           char Text[Length];  
         } NAME;  
         FLOAT YY[7];       
       }; break;

    }; 
  } PROPERTIES;      
} OBJECT_NAME <name=ObjName>;

string ObjName(OBJECT_NAME &objectname) {
  return "Name: " + objectname.HEADER.NAME.Text + " ";
}

struct {
  struct { 
    UINT SectionSize;
    UINT ID; // 10
    struct {
      UINT Length;  
      char Text[Length];  
    } LIGHTLIST_STRING;
  } HEADER <name="ObjectList Header">; 

  UINT Count; 

  typedef struct (int arraySize) {
      OBJECT_NAME array[arraySize] <optimize=false>;
  } OBJECT_NAME_ARRAY;
  OBJECT_NAME_ARRAY ObjectNameArray(Count) <name="Object properties">;
  
} ObjectLIST <name="Object List">;

//-------------------------------------------------------
// RoomList Section
//-------------------------------------------------------


typedef struct {
  struct { 
    UINT ID; //

    UINT Length;  
    char Text[Length]; 
    if (Text == "Version") {
      UINT value; 
      struct {
        UINT Length;  
        char Text[Length];
      } NAME;
    };
  } HEADER <name="Header">;   
 
     switch (HEADER.ID) {
       case 12: {
        BYTE A;
        BYTE B;
        if (B) BYTE c;
        UINT U;
        if (U == 0) BYTE A;
        UINT Length;  
        char ShermanLevel[Length];   

        FLOAT D[6];
        UINT K;
        FLOAT K;
        UINT K;
        BYTE B[K];
        BYTE N[17]; 
       }; break;
       case 3: {
        BYTE A[4];
        UINT U;
        UINT Count;
        struct {
           FLOAT P1;
           FLOAT P2;
           FLOAT P3;
        } Coordinate[Count];
        UINT Count;
        struct {
           FLOAT P1;
           FLOAT P2;
           FLOAT P3;
           FLOAT P1;
           FLOAT P2;
           FLOAT P3;
           UINT P1;
           UINT  P2;
           UINT  P3;
        } Coordinate2[Count];
        UINT Count; 
        struct {
           UINT P1[11];
        } Coordinate3[Count];    
        UINT Count; 
        UINT Count;
        struct {
          UINT Length;  
          char Text[Length];
        } II <optimize=false>;   
        UINT RR[20];
        struct {
          UINT Length;  
          char Text[Length];
        } II <optimize=false>;      
       }; break;
     };

} ROOM <name=RoomName>;

string RoomName(ROOM &room) {
  if (exists(room.HEADER.NAME))
    return "ObjecName: " + room.HEADER.NAME.Text + " ";
  else
    return "ObjecName: " + room.Text + " ";
}

struct {
  struct { 
    UINT SectionSize;
    UINT MN; // 7
    struct {
      UINT Length;  
      char Text[Length];  
    } ROOMLIST_STRING;
  } HEADER <name="ROOMList Header">;

  UINT Count; 

  typedef struct (int arraySize) {
      ROOM array[arraySize] <optimize=false>;
  } ROOM_ARRAY;
  ROOM_ARRAY ROoomArray(Count) <name="data array">;

   
} ROOMLIST <name="Room List">;

//----------------------------------------------
// PlanningLevelLIST
//----------------------------------------------

struct {
  struct { 
    UINT SectionSize;
    UINT MN; // 7
    struct {
      UINT Length;  
      char Text[Length];  
    } PlanningLevelLIST_STRING;
  } HEADER <name="ROOMList Header">;
  
  UINT Count; 

  typedef struct {
    FLOAT A;
    FLOAT B;
    UINT Count;
    typedef struct {
    struct {
      UINT Length;  
      char Text[Length];
    } NAME;
    } A;
    A MN[Count];
  } II;
  typedef struct (int arraySize) {
      II array[arraySize] <optimize=false>;
  } II_ARRAY;
  II_ARRAY IIArray(Count) <name="data array">;
 
} PlanningLevelLIST <name="PlanningLevel List">;

struct {
      UINT Length;  
      char Text[Length];  
} EndMap <name="EndMap">;